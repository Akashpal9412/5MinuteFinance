---
title: "The Pairs Trade"
author: "Matt Brigida"
date: "June 8, 2016"
logo: misq.png
css: 5min_mod.css
output: ioslides_presentation
runtime: shiny
smaller: true
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

<!-- Much of the text and code in this presentation is from here: https://mattbrigida.shinyapps.io/chapter7_pairs_trade/pairs_trade.Rmd  -->

## Market Neutral/Stat Arb

The pairs trade is a market neutral/statistical arbitrage quantitative trading strategy.

- Market Neutral: Market risk is removed in the trading strategy.  Returns on your pairs trade should be uncorrelated with market returns.
- Stat Arb: We find a statistical relationship between two assets, and wait for the relationship to behave differently.  We then trade to profit when the relationship begins to hold again.  This is a loose use of the term 'arbitrage', and is not an arbitrage in the strict sense.

This strategy can be thought of as the opposite of Markowitz mean/variance optimization, which reduces firm specific risk but leaves market risk in our portfolio. 

<div class="MIfooter"><img src="mi.png" style="height:50px;"></div> 

## Law of One Price

The Stat Arb aspect of the pairs trade employs the **law of one price**.  This law says that if two securities have the same payoff in all states of the world, then the two securities must have the same price. 

-  This is enforced by arbitrage. Say the price of security *A* is greater than *B*, and they have the same payoff. Then you could sell *A* and buy *B*, earning \$*Aâˆ’B*, and the payoffs (being the same) will net to \$0.

<div class="MIfooter"><img src="mi.png" style="height:50px;"></div> 

## No One Way

There is no single way to implement the pairs trade. This is an active area of research, and provides you with a venue to create your own strategy.  Following are the general steps of the pairs trade, and your method is any step can be different from methods employed by others.

#.  Choose universe of pairs.
#.  Statistically determine the normal relationship between each pair (estimation period).
#.  Over a later (separate) trading period, watch the pairs to see if any deviate from their estimation period behavior.  If any do, trade the pair.  Close pairs trades for any open pair that returns to normal (or close pairs due to stop losses).
#.  Evaluate strategy performance, and alter the methods in the previous steps.


<div class="MIfooter"><img src="mi.png" style="height:50px;"></div> 

## Your Own Method

The key to the pairs trade is how you implement the above structure.  Some questions are:

-  What metric makes a pair acceptable (same industry, same country, etc)?  How similar do the asset beta coefficient need to be?
-  How will you define the 'normal' statistical relationship?
-  How far does the pair have to deviate firm its normal behavior before you enter the trade?  When do you exit the trade (either take profits or cut losses)?

We'll implement a version of the pairs trade in the following slides, and I'll highlight these decisions.

<div class="MIfooter"><img src="mi.png" style="height:50px;"></div> 

## [Gatev et al (2008)](http://www-stat.wharton.upenn.edu/~steele/Courses/434/434Context/PairsTrading/PairsTradingGGR.pdf)



##

<!-- Estimation Period -->


```{r, messsage=FALSE, warning=FALSE, echo = FALSE}
#{{{
## in the process of translating this code into a Shiny app
## just run for each pair?

inputPanel(
  dateRangeInput("estim_period", "Estimation Period", start = "2015-09-01", end = "2015-12-31"),
  ## selectizeInput(tickers, "Enter Tickers", )
  textInput("ticker1", "First Stock Ticker", value = "JPM"),
  textInput("ticker2", "Second Stock Ticker", value = "GS")
)

renderPrint({
    
library(quantmod)
## Estimation period
from <- input$estim_period[1]
to <- input$estim_period[2]

## The code below to calculate an xts object of returns is from an SO or Quant.SE post.  I need to find it and cite.
env <- new.env()
Symbols <- c(input$ticker1, input$ticker2)
getSymbols(Symbols = Symbols, env = env, from = from, to = to)
args <- eapply(env = env, FUN = function(x){ClCl(x)})[Symbols]
returns <- na.omit(do.call(what = merge, args = args))
colnames(returns) <- Symbols
## convert reutrns to  normalized prices
norm.prices <<- cumsum(returns)

norm.prices.df <- as.data.frame(norm.prices)
## function to find the average squared deviation of the normalized prices for two stocks
  
    ## Calculate the emtimation period parameters (the average squared deviation and the standard deviation of the squared deviations):
    asd.e <<- mean(( norm.prices.df[,1] - norm.prices.df[,2])^2 )
    ssd.e <<- sd(( norm.prices.df[,1] - norm.prices.df[,2])^2 )
    cat("The average squared deviation is", asd.e ,"\n")
    cat("The standard deviation of the squared deviations is:", ssd.e ,"\n")
})
#}}}
```





##

<!-- Chart normalized prices -->


```{r echo=FALSE}
#{{{
library(dygraphs)
renderDygraph({
    update1 <- input$ticker1
    update2 <- input$ticker2
    update.e1 <- input$estim_period
 dygraph(norm.prices) 
#}}} 
})
```
