---
title: "The Cancer Megafund"
author: "[GitHub Contributors](https://github.com/FinancialMarkets/5MinuteFinance/graphs/contributors)"
logo: misq.png
css: 5min_mod2.css
output: ioslides_presentation
runtime: shiny
smaller: true
---

## [Can Financial Engineering Cure Cancer? (2013)](http://www.rogermstein.com/wp-content/uploads/AER2013_Pub1.pdf)

This presentation will introduce you to a present problem in funding cancer research, and possible solutions.  



<div class="MIfooter"><img src="mi.png" style="height:50px;"></div> 





##

```{r echo = FALSE, warning = FALSE, message = FALSE}

## read in simulation ----
#{{{  --------

## below is code written by others.  See first paragraph below, and the GNU License at the end.  It has been modified to allow different input parameters and be displayed as a shiny app.  The original authors are not involved in this modification, so please don't consider the results from this simulation to be in any way endorsed by the original authors.  For their original code see thier Nature Biotechnology paper.  It is also here: 

##################################################################################################################################
##################################################################################################################################
##################################################################################################################################
###################################################### START OF CODE #############################################################
######################################################  01/07/2013   #############################################################
##################################################################################################################################
##################################################################################################################################
##################################################################################################################################
##################################################################################################################################

#This code has been prepared to support the simulations presented in the paper "Commercializing biomedical research through securitization tecniques" (Jose-Maria Fernandez, Roger M. Stein, Andrew W.Lo; Nature Biotechnology; 2012). We want to thank David Fagnan, Lloyd Han, James Noraky, Allister Bernard and Ashutosh Singhal for their excellent coding support work. 
#This is the main function that simulates all the cash flows generated by the transition of the compounds purchased and financed. It starts by defining all the variables of the model and it #also defines eight nested functions that use these variables

simulate.CFs.fn<-function(init=T,show.progress=T)

##This is the main function that simulates the evolution of compounds and its cash flows. 
##It starts by initializing the parameters and variables used in the simulation
##It includes some nested functions that use these variables

{
	if(init) params<<-init.params.fn()
	if(show.progress) prog.bar.click<-round(params$simu$NSIMUS/10,0)
	
    ##-- global variabls & constants ---
   	NSIMUS		<-params$simu$NSIMUS
   	NPERS		<- params$simu$TIMESTEPS
   	HORIZON 	<-NPERS+ceiling(max(params$assets$sale.time))
   	TIMESTEPS	<-params$simu$TIMESTEPS
   	NCOMPOUNDS	<-sum(params$simu$initial.compounds) 
	ALL.STATES	<-c("DSC","PRE","P1","P2","P3","NDA","APP")
	NSTATES		<-length(params$simu$initial.compounds) 
	NBONDS		<-length(params$bonds$capital.structure)-1
	START.STATES<-rep("DSC", params$simu$initial.compounds[1]) 
	AMORT.SCHED	<-matrix(0,NBONDS,NPERS)

	for(i in 2:NSTATES)
	{
		phase<-ALL.STATES[i]
		START.STATES<-c(START.STATES,rep(phase,params$simu$initial.compounds[i]))
	}
	temp.bond.value<-params$bonds$nominal
	for (i in 1:NPERS)
	{    
		for(b in 1:NBONDS)
		{
			timing<-params$bonds$amort.timing
			AMORT.SCHED[b,i]<-calc.amort.pmt.due.fn(i,timing[b,"start"],timing[b,"stop"],params$bonds$nominal[b], temp.bond.value[b])
			temp.bond.value[b]<-temp.bond.value[b] - AMORT.SCHED[b,i]
		}
	}

    ## ----------------------------------

	rho					<-params$assets$rho
	bond.value			<-params$bonds$nominal
   	initial.compounds	<-params$simu$initial.compounds

	invested   			<-rep(T,NCOMPOUNDS)
	sell.value			<-rep(0,NCOMPOUNDS)
	equity.in.compound	<-rep(params$assets$equity.stake,NCOMPOUNDS)
	compounds 			<-START.STATES
	time.in.phase		<-rep(0,NCOMPOUNDS)
	
	first.cash			<-params$simu$initial.cash
	temp.bond.value		<-bond.value
			
	## state of securities
	cash			  	<-c(first.cash,rep(0, HORIZON-1))
	missed.int		    <-rep(0,length(params$bonds$nominal))
	IC.ratio            <-matrix(0,length(params$bonds$nominal), NPERS)
	IC.shortfall		<-matrix(0,length(params$bonds$nominal), NPERS)
	
	##record keeping 
	sales				<-matrix(0,NSIMUS, NSTATES,dimnames=list(rep("a",NSIMUS),ALL.STATES)) 
	withdrawals			<-matrix(0,NSIMUS, NSTATES,dimnames=list(rep("a",NSIMUS),ALL.STATES)) 
	initial.compounds	<-matrix(0,NSIMUS, NSTATES,dimnames=list(rep("a",NSIMUS),ALL.STATES)) 
	sale.times			<-matrix(0,NSIMUS, HORIZON,dimnames=list(rep("a",NSIMUS),paste("S",1:HORIZON,sep="")))
	withdrawal.times	<-matrix(0,NSIMUS, HORIZON,dimnames=list(rep("a",NSIMUS),paste("S",1:HORIZON,sep="")))
	compounds.to.fund	<-matrix(0,NSIMUS, HORIZON,dimnames=list(rep("a",NSIMUS),paste("S",1:HORIZON,sep="")))
	compounds.funded	<-matrix(0,NSIMUS, HORIZON,dimnames=list(rep("a",NSIMUS),paste("S",1:HORIZON,sep="")))
	
	cash.from.coverage	<-matrix(0,NSIMUS,HORIZON) 
	cash.for.investment <-matrix(0,NSIMUS,NPERS)
	interest.paid	  	<-matrix(0,length(params$bonds$nominal), NPERS)
	principal.paid   	<-matrix(0,length(params$bonds$nominal), NPERS)
	history.service		<-matrix(0,NSIMUS)
	cash.realized	  	<-matrix(0,NSIMUS,HORIZON)
	compounds.bought 	<-matrix(0,NSIMUS, NSTATES,dimnames=list(rep("a",NSIMUS),ALL.STATES)) 
	cash.begin.per		<-matrix(0,NSIMUS,HORIZON)

	A1.realized.vals	<-matrix(0,NSIMUS,NPERS)
	A2.realized.vals	<-matrix(0,NSIMUS,NPERS)
	A1.paid				<-matrix(0,NSIMUS,NPERS)
	A2.paid				<-matrix(0,NSIMUS,NPERS)
	A1.defaults			<-rep(T, NSIMUS)
	A2.defaults			<-rep(T, NSIMUS)
	svc.defaults		<-rep(T, NSIMUS)
	return.on.equity	<-rep(0,NSIMUS)
	final.compounds		<-matrix(0,1, NSTATES,dimnames=list(rep("a",1),ALL.STATES)) 
	
		
	##----------------------------------    
    ##- functions that use global vars - 
	##----------------------------------
	
	pay.principal.ffn<-function(cur.per)
	{
		for(b in 1:NBONDS) ##pay principal
		{
			P<<-AMORT.SCHED[b,cur.per]
			principal.paid[b,cur.per]<<-min(P,current.cash)
			current.cash<<-current.cash-principal.paid[b,cur.per]
			bond.value[b]<<-bond.value[b]-principal.paid[b,cur.per]
			if(bond.value[b]<0.0001) bond.value[b]<<-0
		}
		return(NULL)
	}
	
	##----------------------------------
	
	pay.interest.ffn<-function(cur.per)
	{
		for(b in 1:NBONDS) ## pay int
		{
			I<-params$bonds$coupon[b]*bond.value[b]
			interest.paid[b,i]<<-min(I,current.cash)
			current.cash<<-current.cash-interest.paid[b,cur.per]
		}
		return(NULL)
	}
	
	##----------------------------------
	
	check.for.default.ffn<-function(cur.per)
	{
		svc.due <- calc.svc.due.this.per.ffn(bond.value) + unpaid.svc*(1+params$bonds$svc.accrual.int.rate)
		A1.cash.required <- AMORT.SCHED[1,cur.per]+bond.value[1]*params$bonds$coupon[1]
		A2.cash.required <- AMORT.SCHED[2,cur.per]+bond.value[2]*params$bonds$coupon[2]
		cash.required <- svc.due + A1.cash.required + A2.cash.required
		
		if(current.cash < svc.due)
		{
			svc.in.default <- TRUE
			if(bond.value[1]>0) A1.in.default <<- TRUE
			if(bond.value[2]>0) A2.in.default <<- TRUE
		}
		else if(current.cash < svc.due + A1.cash.required)
		{
			A1.in.default <<- TRUE
			if(bond.value[2]>0) A2.in.default <<- TRUE
		}
		else if(current.cash < svc.due + A1.cash.required + A2.cash.required)
		{
			A2.in.default <<- TRUE
		}
		default <- svc.in.default || A1.in.default || A2.in.default
		
		return (default)
	}
	
	##----------------------------------	
	
	check.for.transitions.ffn<-function(rho=0,z=0)
	{
		next_phase<-compounds
		phase.idxs <- phase2index.fn(compounds)
		eligible.idx <- !(compounds=="DSC") & !(compounds=="APP") & !(compounds=="SLD") & invested
		if(!any(eligible.idx)) return (NULL)
		eligible.compounds <- compounds[eligible.idx]
		p<-runif(length(eligible.compounds))
		elig.phase<-determine.current.state.fn(p,params$assets$trans.prob[phase.idxs[eligible.idx],])
		compounds[eligible.idx]<<-elig.phase
		return(NULL)
	}
	
	##----------------------------------
	
	sell.compound.ffn<-function(comp.idx,cur.per)
	{
		remaining.indxs <- comp.idx & !(compounds=="DSC") & !(compounds=="SLD");
		if(!any(remaining.indxs)) return (NULL)
		phase.idxs <- phase2index.fn(compounds[remaining.indxs])
		sale.per<-min(cur.per+ceiling(params$assets$sale.time[phase.idxs]), HORIZON)
		mx<-params$assets$pricing.params[phase.idxs,"vmx"]
		mu   <-params$assets$pricing.params[phase.idxs,"vmu"]
		sigma<-params$assets$pricing.params[phase.idxs,"vsigma"]
		price<-compound.sale.price.fn(compounds[remaining.indxs],sale.per,mu,sigma,mx,rho,z)*equity.in.compound[remaining.indxs]
		## here is where we adjust for uninvested compounds
		rem.not.invested <- !invested[remaining.indxs]
		if(any(rem.not.invested)){
			price[rem.not.invested]<-pmax(price[rem.not.invested]-invest.cost[rem.not.invested],0)
		}
		
		## update main function vars
		update.sale.ffn(price,remaining.indxs,cur.per,FALSE)
		return(price)
	}
	
	##----------------------------------

	withdraw.compound.ffn<-function(old.phase,cur.per)
	{
		counts<-(table(old.phase))
		counts.Per<-((names(counts)))
		counts.Freq<-(as.vector(counts))
		
		##Update main function bookmarking.
		for (loop in (1:length(counts.Per)))
		{
			withdrawals[s,counts.Per[loop]]<<-withdrawals[s,counts.Per[loop]]+counts.Freq[loop]
		}
		withdrawal.times[s,i]<<-withdrawal.times[s,i]+sum(counts.Freq)
		return(NULL)
	}

	##----------------------------------

	transition.compound.ffn<-function(idx)
	{
		ndaidx <- (compounds=="NDA")
		cindxs<-phase2index.fn(compounds[!ndaidx & idx])
		
		##update main function vars
		invested[ndaidx & idx] <<- TRUE
		invested[!ndaidx & idx] <<- FALSE
		invest.cost[!ndaidx & idx]<<-trial.cost.fn(compounds[!ndaidx & idx])+params$assets$pricing.params[cindxs,"Milestone"]
		time.in.phase[idx]<<-0
	}

	##----------------------------------

	calc.svc.due.this.per.ffn<-function(values)
	{
		svc.due.this.per<-params$bonds$servicing.rate*sum(values)
		return(svc.due.this.per)
	}
	##----------------------------------
	
	pay.servicing.ffn<-function(cur.per)
	{
		svc.OK<-T
		if (!in.default)
		{
			svc.due.this.per<-calc.svc.due.this.per.ffn(bond.value)
			svc.past.due<-unpaid.svc*(1+params$bonds$svc.accrual.int.rate)
			svc.due<-svc.due.this.per+svc.past.due
			svc.paid<-min(svc.due,current.cash)
			if(svc.paid<svc.due) svc.OK<-F
		
			## update main function vars
			history.service[s]<<-history.service[s]+svc.paid
			unpaid.svc<<-round((svc.due-svc.paid),5)
			current.cash<<-current.cash-svc.paid
		}
		return(svc.OK)
	}

	##----------------------------------
	
	ic.test.result.ffn<-function(b,i,current.cash)
	{
		if (i !=NPERS)
		{
			sched.svc<-unpaid.svc
			bv<-bond.value[b]
			K<-current.cash
			if(b>1) 
			{ 
				for(bb in 1:(b-1))
				{
					btemp<-bond.value[bb]
					
					N<-min(params$bonds$IC.per,NPERS-i)
					for(m in 1:N)
					{
						K<-K-AMORT.SCHED[bb,i+m]-params$bonds$coupon[bb]*btemp-params$bonds$servicing*btemp
						btemp<-btemp-AMORT.SCHED[bb,i+m]
					}
				}
			}	
			sched.P <- 0
			sched.I <- 0
			
			for(m in 1:min(params$bonds$IC.pers,NPERS-i))
			{
				sched.P<- sched.P + AMORT.SCHED[b,i+m]
				sched.I<- sched.I + params$bonds$coupon[b]*bv
				sched.svc<-sched.svc+params$bonds$servicing*bv
				bv<-bv-AMORT.SCHED[b,i+m]		
			}
			cash.due<-sched.P+sched.I+sched.svc
			IC.ratio<-K/cash.due
		}
		else
		{
			IC.ratio<-params$bonds$interest.coverage[b]
			cash.due<-0
			K<-current.cash
		}
		return (list(IC.ratio=IC.ratio,cash.due=cash.due,K=K))
	}
	
	##----------------------------------	
	update.sale.ffn<-function(price,remaining.indxs,cur.per,forCoverage)
	{
	
		phase.idxs <- phase2index.fn(compounds[remaining.indxs])
		sale.per <- pmin(cur.per+ceiling(params$assets$sale.time[phase.idxs]), HORIZON)
		if(!forCoverage){
			sell.value[remaining.indxs] <- price
		}
		
		##Update main function variables.
		counts<-(table(phase.idxs))
		counts.idx<-(as.numeric(names(counts)))
		counts.freq<-(as.vector(counts))
		
		sales[s,counts.idx]<<-sales[s,counts.idx] + counts.freq
		sale.times[s,cur.per]<<-sale.times[s,cur.per]+sum(counts.freq)
		
		counts <- as.data.frame(table(sale.per))
		counts<-(table(sale.per))
		counts.idx<-(as.numeric(names(counts)))

		
		for (loop in counts.idx)
		{
			cash[loop]<<-cash[loop]+sum(price[loop==sale.per])
			if(forCoverage){
				cash.from.coverage[s,loop]<<-cash.from.coverage[s,loop]+sum(price[loop==sale.per])
			}
		}
	
		compounds[remaining.indxs]<<- rep("SLD",length(compounds[remaining.indxs]))
		time.in.phase[remaining.indxs]<<-0
	}
	
	##----------------------------------	
	liquidate.portfolio.ffn<-function(cur.per)
	{
		remaining.comp.idx<-compounds != "DSC" & compounds !="SLD"
		if(!any(remaining.comp.idx)) return (NULL)
		phase.idxs<-phase2index.fn(compounds[remaining.comp.idx])
		sale.per<-pmin(cur.per+ceiling(params$assets$sale.time[phase.idxs]), HORIZON)
		mu<-params$assets$pricing.params[phase.idxs,"vmu"]
		sigma<-params$assets$pricing.params[phase.idxs,"vsigma"]
		mx<-params$assets$pricing.params[phase.idxs,"vmx"]
		price<-compound.sale.price.fn(compounds[remaining.comp.idx],sale.per,mu,sigma,mx,rho,z)*equity.in.compound[remaining.comp.idx]
		
		rem.inv.cost <- invest.cost[remaining.comp.idx]
		rem.not.invested <- !invested[remaining.comp.idx]
		if(any(rem.not.invested)) price[rem.not.invested]<-pmax(price[rem.not.invested]-rem.inv.cost[rem.not.invested],0)
		##adjust for compounds that have not transitioned at all until liquidation.
		rem.not.transitioned <- time.in.phase[remaining.comp.idx]==cur.per-1
		if(any(rem.not.transitioned)) price[rem.not.transitioned]<-price[rem.not.transitioned]*params$assets$ratio.unchanged
		
		## update main function vars
		update.sale.ffn(price,remaining.comp.idx,cur.per,FALSE)
		return(NULL)
	}

	##----------------------------------	
	
	sell.compounds.to.cover.shortfall.ffn<-function(shortfall,cur.per)
	{
		remaining.comp.idx<-compounds != "DSC" & compounds !="SLD"
		if (sum(remaining.comp.idx) != 0)
		{
			phase.idxs<-phase2index.fn(compounds[remaining.comp.idx])
			sale.per<-pmin(cur.per+ceiling(params$assets$sale.time[remaining.comp.idx]), HORIZON)
			mu<-params$assets$pricing.params[phase.idxs,"vmu"]
			sigma<-params$assets$pricing.params[phase.idxs,"vsigma"]
			mx<-params$assets$pricing.params[phase.idxs,"vmx"]
			prices<-compound.sale.price.fn(compounds[remaining.comp.idx],sale.per,mu,sigma,mx,rho,z)*equity.in.compound[remaining.comp.idx]

			rem.inv.cost <- invest.cost[remaining.comp.idx]
			rem.not.invested <- !(invested[remaining.comp.idx])
			if(any(rem.not.invested))
			{
				prices[rem.not.invested]<-pmax(prices[rem.not.invested]-rem.inv.cost[rem.not.invested],0)		
			}
			
			sorted.idx <-order(prices,decreasing=T)

			cumSale <- cumsum(prices[sorted.idx])
			numSold <- which(cumSale>=shortfall)
			if(length(numSold)==0) numSold <- length(prices)
			else numSold <- numSold[1]

			indxSold <- sorted.idx[1:numSold]

			remaining.comp.loc <- which(remaining.comp.idx)
			
			##update main function vars
			update.sale.ffn(prices[indxSold],remaining.comp.loc[indxSold],cur.per,TRUE)
		}
		return(NULL)
	}
	
	##----------------------------------	
	##----------------------------------	
	##----------------------------------
	
	if(show.progress) cat("Simulation of ",NSIMUS," paths: 0% complete\n")
	startTime<-proc.time()
	for(s in 1:NSIMUS)
	{
		if(show.progress) 
		{ 
			if(!(s %% prog.bar.click)) cat("Simulation ", (s/NSIMUS)*100,"% complete\n")
		}
		
		## reset variables for next path of simulation

		NCOMPOUNDS<-sum(params$simu$initial.compounds)
		
		## state of compounds
		invested   			<-rep(T,NCOMPOUNDS)
		compounds 			<-START.STATES
		time.in.phase		<-rep(0,NCOMPOUNDS)
		first.cash			<-params$simu$initial.cash
		sell.value			<-rep(0,NCOMPOUNDS)
		equity.in.compound	<-rep(params$assets$equity.stake,NCOMPOUNDS)

		## state of securities
		temp.bond.value		<-bond.value
		cash				<-c(rep(0,HORIZON))
		missed.int			<-rep(0,length(params$bonds$nominal))
		IC.ratio        	<-matrix(0,length(params$bonds$nominal)-1, NPERS)
		IC.shortfall    	<-matrix(0,length(params$bonds$nominal)-1, NPERS)
		
		##record keeping 
		interest.paid		<-matrix(0,length(params$bonds$nominal), NPERS)
		principal.paid  	<-matrix(0,length(params$bonds$nominal), NPERS)

		unpaid.svc			<-0
		cash[1]				<-first.cash
		cash.begin.per[s,1]	<-cash[1]

		bond.value			<-params$bonds$nominal
		in.default			<-F
	
		invest.cost			<-trial.cost.fn(compounds)
		
		## temporary variables to make sure we spend only our target percentage
		cash.left.to.spend	<- cash[1] - params$bonds$IC.pers*params$bonds$nominal[1]*params$bonds$coupon[1] -params$bonds$IC.pers*params$bonds$nominal[2]*params$bonds$coupon[2] 
		## number of compounds we actually buy per phase
		num.compounds 		<- rep(0,NSTATES)
		
		money.spent			<- rep(0,NCOMPOUNDS)
		money.saved			<- rep(0, NCOMPOUNDS)

		psindx				<-phase2index.fn(params$assets$sell.in.phase)-1
		cindxs 				<- phase2index.fn(compounds)
		price.tmp			<- invest.cost+params$assets$pricing.params[cindxs,"UpFront"]
		FutureCostEst		<-(psindx>=1)*(params$assets$pricing.params[cindxs,"FutureCostEst"]-params$assets$pricing.params[psindx,"FutureCostEst"])
		
	    for(i in 1:NCOMPOUNDS) 
		{
			## If we have enough cash, buy it and update our initial cash
			if (cash.left.to.spend >= price.tmp[i] + FutureCostEst[i])
			{
				money.spent[i]<- price.tmp[i]
				money.saved[i]<- FutureCostEst[i]
				cash.left.to.spend <- cash.left.to.spend - price.tmp[i] - FutureCostEst[i]
				cash[1]<-cash[1] - price.tmp[i]
				num.compounds[cindxs[i]]<- num.compounds[cindxs[i]] + 1
			}
			else compounds[i]<-"DSC"
		}	

		cash[2]<-cash[1]
		cash.begin.per[s,2]<-cash[1]

		##----- simulate one trajectory ----
		##
		## I) For each time period
		##    1) Check for transitions
		##	 2) Apply waterfall rules
		##		A) if insufficient cash to pay this period's obligations transaction is in default
		##			i) liquidate portfolio 
		##			ii) use proceeds to pay servicing and then all P&I for A1, then P&I for A2, etc.
		##		B) if not in default
		##			i)Pay obligations 
		##				a) Pay servicing
		##				b) Pay P&I for A1, then for A2, etc.
		##			ii) check coverage test 
		##			iii) If coverage is not OK 
		##				a) sell enough assets to bring ratio back in line (coarse approximation)
		##			iv) make investmensts in compounds as cash permits
		## II) If last time period
		##	1) liquidate portfolio
		##	2) Make final payements to bonds
		##	3) Residual cash goes to equity
		##
		
		A1.in.default<-F
		A2.in.default<-F
		svc.in.default<-F
		
		##Value of systematic factor to induce correlations in portfolio valuations.
		z<-rnorm(1)		
		for (i in 2:NPERS) ## during life of bonds
		{
			old.compounds<-compounds
			current.cash<-cash[i]

			## ----------- first determine current state of portfolio
			old.phase	<-compounds
			elig.idxs 	<- invested & !((compounds=="DSC") | (compounds=="SLD") | (compounds=="APP"))
			check.for.transitions.ffn(cur.rho,z)
			
			sell.idxs 	<- elig.idxs & (compounds==params$assets$sell.in.phase)
			sell.compound.ffn(sell.idxs,i)
			
			dsc.idxs 	<- elig.idxs & (compounds=="DSC")
			withdraw.compound.ffn(old.phase[dsc.idxs],i)
			time.in.phase[dsc.idxs]<-0
			
			trans.idxs 	<- elig.idxs & !sell.idxs & !dsc.idxs & !(compounds==old.phase)
			transition.compound.ffn(trans.idxs)
			
			stat.idxs 	<- elig.idxs & !sell.idxs & !dsc.idxs & !trans.idxs
			time.in.phase[stat.idxs]=time.in.phase[stat.idxs]+1
			
			## ----------- accounting balance
			A1.realized.vals[s,i]<-bond.value[1]
			A2.realized.vals[s,i]<-bond.value[2]
			
			##------------ next calc payments of servicing and bonds							
			if(!in.default) in.default <- check.for.default.ffn(i)
			
			##------------ next if not in default pay P&I; if in default liquidate portfolio
			if (!in.default)
			{
				##Now pay current period interest etc.
				pay.servicing.ffn(i)
				pay.interest.ffn(i)
				pay.principal.ffn(i)
				##------------ next check coverage
				for(b in 1:NBONDS) ##calc IC coverage
				{
					if(bond.value[b]>0)
					{
						cash.for.coverage<-current.cash
						if(params$bonds$IC.pers>0) cash.for.coverage<-cash.for.coverage+sum(cash[i+(1:params$bonds$IC.pers)])
						icResult<-ic.test.result.ffn(b,i,cash.for.coverage) 
						IC.ratio[b,i]<-icResult$IC.ratio
						cash.due<-icResult$cash.due
						K<-icResult$K
						IC.shortfall[b,i]<-(params$bonds$interest.coverage[b]*cash.due) - K					
					}
					else IC.shortfall[b]<-0
				}

				##------------ check equity svc coverage
				eq.svc.due<-unpaid.svc
				for (k in 1:ceiling(max(params$assets$sale.time)))
				{
					eq.svc.due<-eq.svc.due + bond.value[length(bond.value)]*params$bonds$servicing
				}
				eq.shortfall<- eq.svc.due - current.cash
					
				##------------ next if IC too low, sell compounds to cover
				max.shortfall<-max(IC.shortfall[,i],eq.shortfall)
				if(max.shortfall > 0) 
				{
					sell.compounds.to.cover.shortfall.ffn(max.shortfall,i)
					OK.to.fund<-F
				}	
				else 
				{
					OK.to.fund<-T
				}				
				##------------ next if IC is OK fund next phases of research for compounds 
				compounds.to.fund[s,i]<-sum(compounds != "DSC" & compounds != "APP" & compounds != "SLD" & !invested)

				if(OK.to.fund)
				{
					if(i<NPERS)
					{
						if(i<NPERS-params$bonds$IC.per) 
						{	next.pers<-(i+1):(i+params$bonds$IC.per)
							num<-params$bonds$IC.pers
						}
						else if (i<(NPERS-params$bonds$IC.per-1))
						{
							next.pers<-(i+1):(i+params$bonds$IC.per-1)
							num<-params$bonds$IC.per-1
						}
						else
						{
							next.pers<-i+1
							num<-1
						}
							
						
						cash.required.for.future<-sum(AMORT.SCHED[,next.pers])+
										num*(
												sum(params$bonds$coupon[1:NBONDS]*bond.value[1:NBONDS])+(params$bonds$servicing.rate*sum(bond.value))
											)
						
						cash.to.invest<-max(current.cash-cash.required.for.future,0)
		
						if(cash.to.invest>0)
						{
							compounds.to.fund.idx<-(1:NCOMPOUNDS)[!invested & compounds != "DSC" & compounds != "APP" & compounds !="SLD"] 								##index of compounds that need funding
							cash.spent<-0
							for(k in compounds.to.fund.idx)
							{
								if(invest.cost[k] <= cash.to.invest) 
								{
									invested[k]<-T
									cash.to.invest<-cash.to.invest-invest.cost[k]
									cash.spent<-cash.spent+invest.cost[k]
									compounds.funded[s,i]<-compounds.funded[s,i]+1
								}
							}
							current.cash<-current.cash-cash.spent 
							cash.for.investment[s,i]<-cash.for.investment[s,i] + cash.spent
						}
					}
				}
			}
			else ## already in default
			{
				liquidate.portfolio.ffn(i)
				pay.servicing.ffn(i) 
				##PAY P&I
				for(b in 1:NBONDS) ## pay down bonds sequentially
					{
						if(current.cash>0)
						{
							I<-min(current.cash,params$bonds$coupon[b]*bond.value[b])
							interest.paid[b,i]<-I
							current.cash<-current.cash-I
							P<-min(current.cash,bond.value[b])
							principal.paid[b,i]<-P
							bond.value[b]<-bond.value[b]-P
							if(bond.value[b]<0.0001) bond.value[b]<-0
							current.cash<-current.cash-P
						}
					}		
			}
			cash[i]<-current.cash
			if(i!=NPERS) 
			{
				##cash left over at end of period accrues interest
				cash[i+1]<-cash[i+1]+(current.cash*(1+params$bonds$cash.accrual.int.rate))
				cash.begin.per[s,i+1]<-cash[i+1]				
			}
			
				
		}	####END TIMESTEP ITERATION#####
		
		final.compounds = final.compounds + c(sum(compounds=='DSC'), sum(compounds=='PRE'), sum(compounds=='P1'), sum(compounds=='P2'), sum(compounds=='P3'), sum(compounds=='NDA'), sum(compounds=='APP'))/NSIMUS
		liquidate.portfolio.ffn(NPERS)

		for(i in NPERS:(HORIZON-1)) 
		{
			current.cash<-cash[i]
			pay.servicing.ffn(i)
			cash[i]<-current.cash
			cash[i+1]<-cash[i]+cash[i+1] 
			cash.begin.per[s,i+1]<-cash[i+1]
		}
		cash.realized[s,]<-cash
		compounds.bought[s,]<-num.compounds

		A1.paid[s,]<-principal.paid[1,]+interest.paid[1,]
		A2.paid[s,]<-principal.paid[2,]+interest.paid[2,]
		A1.defaults[s]<-A1.in.default
		A2.defaults[s]<-A2.in.default
		svc.defaults[s]<-svc.in.default
		return.on.equity[s]<-max((tail(cash,1) - params$bonds$nominal["EQ"])/(params$bonds$nominal["EQ"]),-1)
		
	}	
	
		###END SIM COUNT LOOP#####
	
	ret<-list(
			run.time=proc.time()-startTime,
			cash.begin.per=cash.begin.per,
			cash=cash.realized,
			cash.for.investment=cash.for.investment,
			A1.bals=A1.realized.vals,
			A2.bals=A2.realized.vals,
			amort.sched=AMORT.SCHED,
			A1.payment=A1.paid,
			A2.payment=A2.paid,
			IC.ratio=IC.ratio,
			ROE=return.on.equity,
			sale.phases=sales,
			withdrawal.phases=withdrawals,
			sale.times=sale.times,
			withdrawal.times=withdrawal.times,
			extra.cash.for.coverage=cash.from.coverage,
			servicing=history.service,
			compounds.to.fund=compounds.to.fund,
			compounds.funded=compounds.funded,
			compounds.initially.bought=compounds.bought,
			params=params,
			final.sale.values=sell.value,
			compounds.left = final.compounds,
			A1.defaults = A1.defaults,
			A2.defaults = A2.defaults,
			svc.defaults = svc.defaults
		)
	
	return(ret)
}

##################################################################################################################################
##################################################################################################################################
##################################################################################################################################

init.params.fn<-function()

##initializes all parameters used by the simulation. Contains all default values used.
##Rationale behind these numbers is explained in the Supplementary Information section of the paper "Commercializing biomedical research through securitization tecniques" (Fernandez, Stein, Lo; Nature Biotechnology; October 2012)

{

###------- ASSET PARAMETERS

    a.params<-list(
        rho=0.2,
        trans.prob=matrix(c(
                                        #DSC    PRE	  P1        P2         P3         NDA        APP
                                        #
            1.000000000000000,  0,   0,        			0,         			0.000000000000000, 	0,         			0,          				#DSC
            0.155000000000000,  0.5, 0.345,    			0,         			0.000000000000000,	0,         			0,         				#PRE
            0.053215560704185,  0,   0.807859886086702,	0.133437226118754, 	0.005307429700172,	0.000157443915296,	0.000022453474890,		#P1
            0.085093613975923,  0,   0,    				0.844734609586595,	0.066750087871169,	0.002866145785922, 	0.000555542780392,    	#P2
            0.062545675724766,  0,   0,        			0,         			0.848420924719526,	0.068234113621235, 	0.020799285934472,    	#P3
            0.021663504081486,  0,   0,        			0,         			0,         			0.566729918370271, 	0.411606577548242,    	#NDA
            0,			        0,   0,        			0,         			0,         			0,         			1.000000000000000    	#APP
        ),
        byrow=T,
        nrow=7,ncol=7, 
        dimnames=list
        (
            c("DSC","PRE","P1","P2","P3","NDA","APP"),
            c("DSC","PRE","P1","P2","P3","NDA","APP")
        )
        ),  
        pricing.params=matrix(c(
                                        #     vmu     vsimga   vmx   UpFront   MileStone    mu       sigma      max   FutureCostEst
            0,      			1,         0,  	0,		          	0,     				0,       			0,          0,      0,     #DSC
            2.354733621857371, 0.939,   100,  	2.506648325603443, 	1.253324162801722,  1.573797446769595,  0.785050619780075,      20,    	134,     #PRE
            2.976737648081240, 0.939,   250,  	7.519944976810328, 	3.759972488405164,  2.722501027059631,  0.732114106934504,    50,    	121,     #P1
            3.996945974057142, 0.939,   500,   20.053186604827545,	10.026593302413772, 3.702027419856847,  0.795995957236353,     	120,   	85,     #P2
            5.802748472629424, 0.939,  1000,  	75.199449768103278,	37.599724884051639, 5.065276957812039,	0.633123896262475,   	500,    0,     #P3
            7.277762431143847, 0.939,  2500,  	0,          		0,    				0,       			0,          0,      0,     #NDA
            7.239151725642049, 0.939,  5000, 	0,          		0,    				0,       			0,          0,      0     #APP
        ),
        byrow=T,
        nrow=7,ncol=9,
        dimnames=list
        (
            c("DSC","PRE","P1","P2","P3","NDA","APP"),
            c("vmu","vsigma","vmx","UpFront","Milestone","mu","sigma","max","FutureCostEst")
        )

        ),

        sell.in.phase="P2",
        sale.time=c(DSC=1.5,PRE=1.5,P1=1.5,P2=1.5,P3=1.5,NDA=1.5,APP=1.5),
        ratio.unchanged = 1,
        equity.stake = 0.85
    )	
	
	# ------- BOND PARAMETERS	

	temp.sched<-rep(0,)
	
	b.params<-list(
		capital.structure=c(A1=0.25,A2=0.15,EQ=0.6),
		nominal=NULL,
		interest.coverage=c(A1=1.75,A2=3.5,EQ=0),
		IC.pers=2,
		amort.timing=matrix(c(
			 5,  8,
			 9, 12
			),
			byrow=T,
			nrow=2,ncol=2,
			dimnames=list
         	(
         			c("A1","A2"),
         			c("start","stop")
         	)
		),
		coupon=c(A1=0.05/2,A2=0.08/2,EQ=0),
		servicing.rate=0.0025,
		svc.accrual.int.rate=0.07/2,
		cash.accrual.int.rate=.01/2
	)


# ------- SIMU PARAMETERS

	s.params<-list(
		NSIMUS=1000,
		TIMESTEPS=max(b.params$amort.timing)+1,
		initial.cash=5000,
		initial.compounds=c(DSC=0,PRE=100,P1=100,P2=0,P3=0,NDA=0,APP=0) 
	)

	b.params$nominal<-s.params$initial.cash*b.params$capital.structure
	
	return(list(simu=s.params,assets=a.params,bonds=b.params))
}

##################################################################################################################################
##################################################################################################################################
##################################################################################################################################

calc.amort.pmt.due.fn<-function(per,a.start,a.end,orig.par, cur.par)
{
	
	# Calculate principal payment due in period per
	amort.per<-a.end-a.start+1
	if ( per >= a.start && per<=a.end )
	{
		if (orig.par/amort.per < cur.par) pmt<-orig.par/amort.per
		else pmt<-cur.par
	}
	else pmt<-0
	return(pmt)
}


##################################################################################################################################
##################################################################################################################################
##################################################################################################################################

compound.sale.price.fn<-function(comp.phase,per,mu,sigma,mx,rho,z) 
{
	# Calculate value of compounds sold

	if(rho==0) {
		 v<-min(rlnorm(1,mu,sigma),mx)
	}
	else
	{
		ej<-rnorm(length(mu))
		Z<-(sqrt(rho)*z)+(sqrt(1-rho)*ej)
		X<-Z*sigma+mu
		v<-pmin(exp(X),mx)
	}
	
	return(v)

}

##################################################################################################################################
##################################################################################################################################
##################################################################################################################################

determine.current.state.fn<-function(p,dist)
{
	res<-rep("",length(p))
	if(length(p)==1) dist<-t(as.matrix(dist))
	len<-NCOL(dist)
	cdist<-t(apply(dist,1,cumsum))
	cdist[,len]<-rep(1,NROW(cdist))
	i<-rep(0,NROW(dist))
	for (loop in 1:len) 
	{
		i<-i+loop*(t(cdist[,loop])>p)*(i<=0)
	}
	res<-colnames(cdist)[i]
	return (res)
}

##################################################################################################################################
##################################################################################################################################
##################################################################################################################################

phase2index.fn<-function(phase)
{
	#
	# Convert character string representation of phase into an index
	#      phase is vector of "DSC", "P1","P2","P3","NDA", "APP"
	#
	indxs <- rep(0,(length(phase)))
	phase.names <- c("DSC","PRE","P1","P2","P3","NDA", "APP")
	for (i in 1:length(phase.names))
	{
		indxs <- indxs + i*(phase.names[i]==phase)
	}
	
	return (indxs)
}


##################################################################################################################################
##################################################################################################################################
##################################################################################################################################
plot.standard.diagnostics.fn<-function(results) 
{
	# plot graph to display main results of simulation
	par(mfrow=c(3,2))
	par(cex=0.5)
	plot.trajectories.fn(results$cash,main="Cash - Quantiles",quant=T)
   	ROE.raw<-results$ROE
	NYEARS<-length(results$cash[1,])/2
    ROE.annualized<-((1+ROE.raw)^(1/NYEARS))-1
	hist(ROE.annualized,main="ROE.annualized",col=4,xlab="")
	#
	plot.trajectories.fn(results$A1.bals,main="A1 balance - Quantiles",quant=T)
	plot.trajectories.fn(results$A2.bals,main="A2 balance - Quantiles",quant=T)
	#
    sale.phases<-colMeans(results$sale.phases)
    withdrawal.phases<-colMeans(results$withdrawal.phases)
   	col.names<-names(withdrawal.phases)
   	row.names<-c("Sales:","WD:")
   	exits<-matrix(c(sale.phases,withdrawal.phases),2,length(col.names),dimnames=list(row.names,col.names),byrow=T)
   	barplot(exits,space=c(0,0.5),col=c(3,2),beside=T,main="Mean # compounds sold (green) or withdrawn (red) in phase")

   	#
   	sale.times<-colMeans(results$sale.times)
    withdrawal.times<-colMeans(results$withdrawal.times)
   	col.names<-names(withdrawal.times)
   	exit.times<-matrix(c(sale.times,withdrawal.times),2,length(col.names),dimnames=list(row.names,col.names),byrow=T)
   	barplot(exit.times,space=c(0,0.5),col=c(3,2),beside=T,main="Mean # compounds sold (green) or withdrawn (red) in period")
}

##################################################################################################################################
##################################################################################################################################
##################################################################################################################################

plot.trajectories.fn<-function(paths,n=0,quant=F,...) 
{
	if(quant)
	{
		series<-apply(paths,2,FUN=quantile)
	}
	else
	{
		series<-paths
	}
	len<-length(series[1,])
	N<-length(series[,1])
	if(n==0) n<-N
	mx<-max(series)
	mn<-min(series)

	plot(1:len,smooth(unlist(series[1,1:len])),ylab="",xlab="Period",type="l",ylim=c(mn,mx),...)
	for(i in 2:min(n,N)) lines(1:len,smooth(unlist(series[i,1:len])),type="l",col=i+7)
}

##################################################################################################################################
##################################################################################################################################
##################################################################################################################################

summarize.results.fn<-function(results,plot=T) 
{

	# displays main results from simulation
    HORIZON<-length(results$cash[1,])
    NPERS<-length(results$A1.bals[1,])
    NYEARS<-HORIZON/2
	NSIMUS <- results$params$simu$NSIMUS;
    NCOMPOUNDS<-sum(results$params$simu$initial.compounds)
    sale.phases<-colMeans(results$sale.phases)
    withdrawal.phases<-colMeans(results$withdrawal.phases)
    sale.times<-colMeans(results$sale.times)
    withdrawal.times<-colMeans(results$withdrawal.times)
	col.names<-names(withdrawal.phases)
	row.names<-c("Sales:","WD:")
	exits<-matrix(c(sale.phases,withdrawal.phases),2,length(col.names),dimnames=list(row.names,col.names),byrow=T)
	sale.times<-colMeans(results$sale.times)
    withdrawal.times<-colMeans(results$withdrawal.times)
	col.names<-names(withdrawal.times)
	exit.times<-matrix(c(sale.times,withdrawal.times),2,length(col.names),dimnames=list(row.names,col.names),byrow=T)
	row.names<-c("Funds needed","Funds invested")
	funds.needed<-colMeans(results$compounds.to.fund)
	funds.done<-colMeans(results$compounds.funded)
	funding<-matrix(c(funds.needed,funds.done),2,length(col.names),dimnames=list(row.names,col.names),byrow=T)
   
    A1.gt.0  <- results$A1.bals[,results$params$bonds$amort.timing["A1","stop"]+1]>0
    A2.gt.0  <- results$A2.bals[,results$params$bonds$amort.timing["A2","stop"]+1]>0
    p1<-mean(A1.gt.0)
    p2<-mean(A2.gt.0)
    el1<-(mean(results$A1.bals[,NPERS])/params$bonds$nominal["A1"])
    el2<-(mean(results$A2.bals[,NPERS])/params$bonds$nominal["A2"])
    loss.stats<-matrix(c(p1,p2,el1,el2),2,2,dimnames=list(c("PD","EL"),c("A1","A2")),byrow=T)
    PD<-c(A1=p1,A2=p2)
    EL<-c(A1=el1,A2=el2)
    ROE.raw<-results$ROE
    ROE.annualized<-((1+ROE.raw)^(1/NYEARS))-1
    ROE.mean<-mean(ROE.raw)
    ROE.mean.a<-mean(ROE.annualized)
    ROE.quant<-quantile(ROE.raw)
    ROE.quant.a<-quantile(ROE.annualized)
    ROE.q<-matrix(c(ROE.quant,ROE.quant.a),2,5,byrow=T,dimnames=list(c("TOT","ANN"),c("0","25","median","75","100")))
    p.EQ.wipeout<-mean(ROE.annualized==-1)
    p.EQ.loss<-mean(ROE.annualized<0)
    p.EQ.pos<-mean(ROE.annualized>=0)
    p.EQ.05<-mean(ROE.annualized>0.05)
    p.EQ.10<-mean(ROE.annualized>=0.1)
    p.EQ.15<-mean(ROE.annualized>0.15)
    p.EQ.25<-mean(ROE.annualized>0.25)
    EQ.probs<-matrix(
    c(p.EQ.wipeout,p.EQ.loss,p.EQ.pos,p.EQ.05,p.EQ.10,p.EQ.15,p.EQ.25),
		1,7,
		dimnames=list( c("p(x)"),
			c("EQ=0","EQ.loss","EQ.pos","EQ>0.05","EQ>0.10","EQ>0.15","EQ>0.25")),
		byrow=T
		)
    ROE<-matrix(c(ROE.mean,ROE.mean.a),1,2, byrow=T,dimnames=list(c("E[ROE]"),c("TOT","ANN")))
	
    cat("\n\nv==================================v\n")
    cat("\n# Simu:",params$simu$NSIMU,". Horizon: ",NYEARS,"years.\n")
    cat("\n--------- ASSET  ANALYSIS ----------\n\n")
    cat("Initial target portfoilio contains ",NCOMPOUNDS," compounds:\n")
    print(results$params$simu$initial.compounds)
    cat("\nMean number of compounds initially purchased:\n")
    print(colMeans(results$compounds.initially.bought))
    cat("\nMean number of compounds exiting in each state:\n")
    print(exits)
    cat("\nMean number of compounds exiting in each period:\n")
    print(exit.times)
    cat("\nMean number of compounds funded in each period:\n")
    print(funding)    
    cat("\n--------- EQUITY ANALYSIS ----------\n\n")
    print(round(ROE, 3))
    cat("\nquant(ROE)\n")
    print(round(ROE.q,3))
    cat("\n")
    print(round(EQ.probs,5))
    cat("\n---------  BOND ANALYSIS  ----------\n\n")
    print(round(loss.stats,5))
    
    cat("\n\n^==================================^\n\n")
    
	if(plot) plot.standard.diagnostics.fn(results)
}


##################################################################################################################################
##################################################################################################################################
##################################################################################################################################

trial.cost.fn<-function(comp.phase)
{
	# 
	# Determine cost of funding trials (stochastically) for phase comp.phase
	#      comp.phase is vector of "DSC","P1","P2","P3","NDA", "APP"
	#
	cost<-rep(0,length(comp.phase))
	rowidxs <- phase2index.fn(comp.phase)
	elig.idx <- !((comp.phase=="DSC") |(comp.phase=="NDA") | (comp.phase=="APP") | (comp.phase=="SLD"))
	if(!any(elig.idx)) return (cost)
	
	mu<-params$asset$pricing.params[rowidxs[elig.idx],"mu"]
	sigma<-params$asset$pricing.params[rowidxs[elig.idx],"sigma"]
	mx<-params$asset$pricing.params[rowidxs[elig.idx],"max"]
	
	raw.cost<-rlnorm(length(mu),mu,sigma)
	cost[elig.idx]<-pmin(raw.cost,mx)
	return(cost)
}

##################################################################################################################################
##################################################################################################################################
##################################################################################################################################
##################################################################################################################################
######################################################### END OF CODE ############################################################
##################################################################################################################################
##################################################################################################################################
##################################################################################################################################
##################################################################################################################################



#COPYRIGHT 2012,2013
# This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#

#}}} -----

## Shiny app starts here-----

ui <- bootstrapPage(
        tabsetPanel(type = "tabs",
                    # tabPanel("Data", DT::dataTableOutput("datatable")),
                    tabPanel("Plot", plotOutput("plot1")),
                    tabPanel("Plot", plotOutput("plot2")),
                    tabPanel("Plot", plotOutput("plot3")),
                    tabPanel("Plot", plotOutput("plot4"))
                    )
    )
    
server <- function(input, output){

    results <<- simulate.CFs.fn()

output$plot1 <- renderPlot({ 

summarize.results.fn(results)

})

    output$plot2 <- renderPlot({ 

summarize.results.fn(results)

})

}

shinyApp(ui = ui, server = server)
```







## Credits and Collaboration

Click [here](https://github.com/FinancialMarkets/5MinuteFinance/blob/master/Options/black_scholes/black_scholes.Rmd) to see the code and collaborators for this presentation

If you would like to make any additions or corrections to this presentation, visit our [GitHub repository page](https://github.com/FinancialMarkets/5MinuteFinance#how-to-contribute) to learn more about how to contribute

<div class="MIfooter"><img src="mi.png" style="height:50px;"></div> 
